{"version":3,"file":"export.js","sourceRoot":"","sources":["../../../../src/lib/converter/nodes/export.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,+BAAiC;AAEjC,4CAAqF;AAErF,4CAAgE;AAGhE,IAAa,eAAe;IAAS,mCAA2C;IADhF;QAAA,qEAgDC;QA3CG,cAAQ,GAAoB;YACxB,EAAE,CAAC,UAAU,CAAC,gBAAgB;SACjC,CAAC;;IAyCN,CAAC;IAvCG,iCAAO,GAAP,UAAQ,OAAgB,EAAE,IAAyB;QAC/C,IAAI,MAAM,GAAc,SAAS,CAAC;QAGlC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,EAAE,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;YACrF,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC3D,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,IAAI,IAAI,GAAG,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YACtD,MAAM,GAAG,IAAI,GAAG,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;QAC5C,CAAC;QACD,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;YACT,IAAM,SAAO,GAAG,OAAO,CAAC,OAAO,CAAC;YAChC,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,UAAC,WAAW;gBACpC,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC;oBACtB,MAAM,CAAC;gBACX,CAAC;gBACD,IAAM,EAAE,GAAG,SAAO,CAAC,aAAa,CAAC,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC;gBAC1E,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBACN,MAAM,CAAC;gBACX,CAAC;gBAED,IAAM,UAAU,GAAG,SAAO,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;gBAC3C,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,IAAI,UAAU,YAAY,6BAAqB,CAAC,CAAC,CAAC;oBAC5C,UAAW,CAAC,OAAO,CAAC,sBAAc,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAC;gBACxF,CAAC;gBACD,cAAc,CAAC,UAAU,CAAC,CAAC;YAC/B,CAAC,CAAC,CAAC;QACP,CAAC;QAED,wBAAwB,UAAsB;YAC1C,EAAE,CAAC,CAAC,UAAU,YAAY,6BAAqB,CAAC,CAAC,CAAC;gBACrB,UAAW,CAAC,OAAO,CAAC,sBAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;YAChF,CAAC;YAED,UAAU,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;QACxC,CAAC;QAED,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC;IACzB,CAAC;IACL,sBAAC;AAAD,CAAC,AA/CD,CAAqC,mCAAsB,GA+C1D;AA/CY,eAAe;IAD3B,sBAAS,CAAC,EAAC,IAAI,EAAE,aAAa,EAAC,CAAC;GACpB,eAAe,CA+C3B;AA/CY,0CAAe","sourcesContent":["import * as ts from 'typescript';\n\nimport {Reflection, ReflectionFlag, DeclarationReflection} from '../../models/index';\nimport {Context} from '../context';\nimport {Component, ConverterNodeComponent} from '../components';\n\n@Component({name: 'node:export'})\nexport class ExportConverter extends ConverterNodeComponent<ts.ExportAssignment> {\n    /**\n     * List of supported TypeScript syntax kinds.\n     */\n    supports: ts.SyntaxKind[] = [\n        ts.SyntaxKind.ExportAssignment\n    ];\n\n    convert(context: Context, node: ts.ExportAssignment): Reflection {\n        let symbol: ts.Symbol = undefined;\n\n        // default export\n        if (node.symbol && (node.symbol.flags & ts.SymbolFlags.Alias) === ts.SymbolFlags.Alias) {\n            symbol = context.checker.getAliasedSymbol(node.symbol);\n        } else {\n            let type = context.getTypeAtLocation(node.expression);\n            symbol = type ? type.symbol : undefined;\n        }\n        if (symbol) {\n            const project = context.project;\n            symbol.declarations.forEach((declaration) => {\n                if (!declaration.symbol) {\n                    return;\n                }\n                const id = project.symbolMapping[context.getSymbolID(declaration.symbol)];\n                if (!id) {\n                    return;\n                }\n\n                const reflection = project.reflections[id];\n                if (node.isExportEquals && reflection instanceof DeclarationReflection) {\n                    (<DeclarationReflection> reflection).setFlag(ReflectionFlag.ExportAssignment, true);\n                }\n                markAsExported(reflection);\n            });\n        }\n\n        function markAsExported(reflection: Reflection) {\n            if (reflection instanceof DeclarationReflection) {\n                (<DeclarationReflection> reflection).setFlag(ReflectionFlag.Exported, true);\n            }\n\n            reflection.traverse(markAsExported);\n        }\n\n        return context.scope;\n    }\n}\n"]}